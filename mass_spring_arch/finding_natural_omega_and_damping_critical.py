import numpy as np
from numpy import sqrt
from scipy.optimize import fsolve

# ------------------------------------------------------------
# 1. Параметры
# ------------------------------------------------------------
a1 = 0.5
a2 = 0.5
a3 = 0.5  # м
l01 = 1.0
l02 = 0.5
l03 = 1.0  # м
k1 = 3.0e7
k2 = 3.0e6
k3 = 3.0e7  # Н/м
k_theta = 2.0e3  # Н·м/рад
m = 1.0  # кг

# Внешние постоянные силы:
F1 = 0#-6e6
F2 = 0#-6e6

# ------------------------------------------------------------
# 2. Геометрические и энергетические производные
# ------------------------------------------------------------
def geometry(y1, y2):
    dL1 = sqrt(a1**2 + y1**2) - l01
    dL2 = sqrt(a2**2 + (y2 - y1)**2) - l02
    dL3 = sqrt(a3**2 + y2**2) - l03

    th1 = np.arctan2(y1, a1)
    th2 = np.arctan2(y2, a3)

    # Первые производные
    dL1_y1 = y1 / sqrt(a1**2 + y1**2)
    dL2_y1 = (y1 - y2) / sqrt(a2**2 + (y2 - y1)**2)
    dTh1_y1 = a1 / (a1**2 + y1**2)

    dL3_y2 = y2 / sqrt(a3**2 + y2**2)
    dL2_y2 = (y2 - y1) / sqrt(a2**2 + (y2 - y1)**2)
    dTh2_y2 = a3 / (a3**2 + y2**2)

    # Вторые производные
    d2L1_y1 = (a1**2) / (a1**2 + y1**2)**1.5
    d2L2_y1y1 = (a2**2) / (a2**2 + (y2 - y1)**2)**1.5
    d2Th1_y1 = -2*a1*y1 / (a1**2 + y1**2)**2

    d2L3_y2 = (a3**2) / (a3**2 + y2**2)**1.5
    d2L2_y2y2 = (a2**2) / (a2**2 + (y2 - y1)**2)**1.5
    d2Th2_y2 = -2*a3*y2 / (a3**2 + y2**2)**2

    # Смешанная
    d2L2_y1y2 = -a2**2 / (a2**2 + (y2 - y1)**2)**1.5

    return (dL1, dL2, dL3, th1, th2,
            dL1_y1, dL2_y1, dTh1_y1,
            dL3_y2, dL2_y2, dTh2_y2,
            d2L1_y1, d2L2_y1y1, d2Th1_y1,
            d2L3_y2, d2L2_y2y2, d2Th2_y2,
            d2L2_y1y2)

# ------------------------------------------------------------
# 3. Система уравнений равновесия ∂P/∂y = 0
# ------------------------------------------------------------
def residual(Y):
    y1, y2 = Y
    (dL1, dL2, dL3, th1, th2,
     dL1_y1, dL2_y1, dTh1_y1,
     dL3_y2, dL2_y2, dTh2_y2,
     *_) = geometry(y1, y2)

    dP_dy1 = (k1 * dL1 * dL1_y1 +
              k2 * dL2 * dL2_y1 +
              k_theta * th1 * dTh1_y1) - F1
    dP_dy2 = (k3 * dL3 * dL3_y2 +
              k2 * dL2 * dL2_y2 +
              k_theta * th2 * dTh2_y2) - F2
    return [dP_dy1, dP_dy2]

# начальное приближение рядом с (0.866, 0.866)
Y0 = [0.866, 0.866]
y_eq = fsolve(residual, Y0)
y1_eq, y2_eq = y_eq
print("Равновесие: y1* =", y1_eq, "м, y2* =", y2_eq, "м")

# ------------------------------------------------------------
# 4. Построение матрицы жёсткости K в точке равновесия
# ------------------------------------------------------------
(dL1, dL2, dL3, th1, th2,
 dL1_y1, dL2_y1, dTh1_y1,
 dL3_y2, dL2_y2, dTh2_y2,
 d2L1_y1, d2L2_y1y1, d2Th1_y1,
 d2L3_y2, d2L2_y2y2, d2Th2_y2,
 d2L2_y1y2) = geometry(y1_eq, y2_eq)

K11 = (k1*(dL1_y1**2 + dL1*d2L1_y1) +
       k2*(dL2_y1**2 + dL2*d2L2_y1y1) +
       k_theta*(dTh1_y1**2 + th1*d2Th1_y1))

K22 = (k3*(dL3_y2**2 + dL3*d2L3_y2) +
       k2*(dL2_y2**2 + dL2*d2L2_y2y2) +
       k_theta*(dTh2_y2**2 + th2*d2Th2_y2))

K12 = k2*(dL2_y1*dL2_y2 + dL2*d2L2_y1y2)
K = np.array([[K11, K12],
              [K12, K22]])

print("Матрица жёсткости K:\n", K)

# ------------------------------------------------------------
# 5. Собственные частоты и критическое демпфирование
# ------------------------------------------------------------
eigvals = np.linalg.eigvals(K / m)
omega = np.sqrt(np.abs(eigvals))
c_cr = 2 * m * np.max(omega)

print("Натуральные частоты ω:", omega)
print("Критическое демпфирование c_cr =", c_cr, "Н·с/м")
